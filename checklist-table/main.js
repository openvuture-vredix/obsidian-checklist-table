/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

// ============================================================================
// ESBUILD BOILERPLATE
// ============================================================================

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;

var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};

var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);


// ============================================================================
// IMPORTS & KONSTANTEN
// ============================================================================

var main_exports = {};
__export(main_exports, {
  default: () => ChecklistTablePlugin
});
module.exports = __toCommonJS(main_exports);

var import_obsidian = require("obsidian");

// ============================================================================
// INTERNATIONALISIERUNG (i18n)
// ============================================================================

var TRANSLATIONS = {
  en: {
    defaultColumns: ["Task", "Details"],
    addTaskButton: "+",
    statusOpen: "Open",
    statusDone: "Done",
    statusCancelled: "Cancelled",
    statusImportant: "Important",
    statusForwarded: "Forwarded",
    statusScheduled: "Scheduled",
    settingsTitle: "Checklist Table Settings",
    settingsDefaultColumns: "Default Columns",
    settingsDefaultColumnsDesc: "Comma-separated list of default column headers",
    settingsPlaceholder: "Topic, Task",
    commandInsertChecklist: "Insert Checklist Block",
    settingsLanguage: "Language",
    settingsLanguageDesc: "Choose the language for the plugin interface (requires plugin reload)",
    languageAuto: "Auto (System)",
    languageEnglish: "English",
    languageGerman: "Deutsch",
    settingsAlwaysShowControls: "Always Show Controls",
    settingsAlwaysShowControlsDesc: "Always show progress bar and add button (otherwise only on hover)"
  },
  de: {
    defaultColumns: ["Aufgabe", "Details"],
    addTaskButton: "+",
    statusOpen: "Unerledigt",
    statusDone: "Erledigt",
    statusCancelled: "Abgebrochen",
    statusImportant: "Wichtig",
    statusForwarded: "Verschoben",
    statusScheduled: "Zurückgestellt",
    settingsTitle: "Checklist Tabelle Einstellungen",
    settingsDefaultColumns: "Standard-Spalten",
    settingsDefaultColumnsDesc: "Komma-getrennte Liste der Standard-Spalten",
    settingsPlaceholder: "Themenbereich, Aufgabe",
    commandInsertChecklist: "Checklist-Block einfügen",
    settingsLanguage: "Sprache",
    settingsLanguageDesc: "Wähle die Sprache für die Plugin-Oberfläche (erfordert Plugin-Neustart)",
    languageAuto: "Automatisch (System)",
    languageEnglish: "English",
    languageGerman: "Deutsch",
    settingsAlwaysShowControls: "Steuerelemente immer anzeigen",
    settingsAlwaysShowControlsDesc: "Fortschrittsbalken und Hinzufügen-Button immer anzeigen (sonst nur beim Hover)"
  }
};

// Standard-Einstellungen
var DEFAULT_SETTINGS = {
  defaultColumns: ["Task", "Details"],
  locale: "auto",
  alwaysShowControls: false
};

// Erkenne System-Locale
var systemLocale = (window.navigator.language || "en").split("-")[0];
if (!TRANSLATIONS[systemLocale]) {
  systemLocale = "en";
}

var currentLocale = systemLocale;

// Funktion zur Aktualisierung der Locale
function updateLocale(settings) {
  if (settings.locale === "auto") {
    currentLocale = systemLocale;
  } else {
    currentLocale = settings.locale;
  }
}

// Übersetzungs-Funktion
function t(key) {
  return TRANSLATIONS[currentLocale][key] || TRANSLATIONS["en"][key] || key;
}


// ============================================================================
// HAUPT-PLUGIN-KLASSE
// ============================================================================

var ChecklistTablePlugin = class extends import_obsidian.Plugin {

  // -------------------------
  // Plugin Initialisierung
  // -------------------------

  async onload() {
    await this.loadSettings();

    // Registriere Codeblock-Prozessor für ```checklist
    this.registerMarkdownCodeBlockProcessor("checklist", (source, el, ctx) => {
      this.processChecklistBlock(source, el, ctx);
    });

    // Registriere Command zum Einfügen eines Checklist-Blocks
    this.addCommand({
      id: "insert-checklist-block",
      name: t("commandInsertChecklist"),
      editorCallback: (editor) => {
        const defaultCols = this.settings.defaultColumns;
        const template = `\`\`\`checklist
| ${defaultCols.join(" | ")} |
[ ]
\`\`\``;
        editor.replaceSelection(template);

        // Setze Cursor in die erste Task-Zeile
        const cursor = editor.getCursor();
        editor.setCursor({
          line: cursor.line - 2,
          ch: 4
        });
      }
    });

    this.addSettingTab(new ChecklistTableSettingTab(this.app, this));
  }


  // ============================================================================
  // CHECKBOX VERWALTUNG
  // ============================================================================

  // -------------------------
  // Aktualisiert Checkbox-Darstellung basierend auf Status
  // Status: " " = offen, "x" = erledigt, "-" = abgebrochen, "!" = wichtig, etc.
  // -------------------------

  updateCheckboxAppearance(checkboxDiv, status, row) {
    // Entferne alle Status-Klassen
    checkboxDiv.removeClass("status-done", "status-cancelled", "status-important", "status-forwarded", "status-scheduled");

    // Setze neues Symbol und Klasse basierend auf Status
    switch (status) {
      case "x":
      case "X":
        checkboxDiv.setText("✓");
        checkboxDiv.addClass("status-done");
        break;

      case "-":
        checkboxDiv.setText("−");
        checkboxDiv.addClass("status-cancelled");
        break;

      case "!":
        checkboxDiv.setText("!");
        checkboxDiv.addClass("status-important");
        break;

      case ">":
        checkboxDiv.setText("›");
        checkboxDiv.addClass("status-forwarded");
        break;

      case "<":
        checkboxDiv.setText("‹");
        checkboxDiv.addClass("status-scheduled");
        break;

      default:
        checkboxDiv.setText("");
        break;
    }
  }


  // -------------------------
  // Zeigt Rechtsklick-Menü zur Status-Auswahl
  // -------------------------

  showTaskStatusMenu(event, checkboxDiv, row, tbody, container, saveTaskStatus, updateProgressBar) {
    // Erstelle Menü-Container
    const menu = document.createElement("div");
    menu.addClass("checklist-context-menu");

    // Definiere verfügbare Status
    const statuses = [
      { symbol: " ", label: t("statusOpen"), icon: "☐" },
      { symbol: "x", label: t("statusDone"), icon: "✓" },
      { symbol: "-", label: t("statusCancelled"), icon: "−" },
      { symbol: "!", label: t("statusImportant"), icon: "!" },
      { symbol: ">", label: t("statusForwarded"), icon: "›" },
      { symbol: "<", label: t("statusScheduled"), icon: "‹" }
    ];

    // Erstelle Menü-Einträge
    statuses.forEach((status) => {
      const item = menu.createDiv({ cls: "checklist-menu-item" });
      item.createSpan({ cls: "checklist-menu-icon", text: status.icon });
      item.createSpan({ cls: "checklist-menu-label", text: status.label });

      // Status-Änderung bei Klick
      item.addEventListener("click", async () => {
        checkboxDiv.setAttribute("data-status", status.symbol);
        this.updateCheckboxAppearance(checkboxDiv, status.symbol, row);
        menu.remove();

        // Speichere Status und aktualisiere Fortschrittsbalken
        const originalLine = row.getAttribute("data-original-line");
        await saveTaskStatus(originalLine, status.symbol);

        const progressFill = container.querySelector(".checklist-progress-fill");
        const progressCounter = container.querySelector(".checklist-progress-counter");
        if (progressFill && progressCounter) {
          updateProgressBar(tbody, progressFill, progressCounter);
        }
      });
    });

    // Positioniere Menü an Mausposition
    menu.style.position = "fixed";
    menu.style.left = event.clientX + "px";
    menu.style.top = event.clientY + "px";
    document.body.appendChild(menu);

    // Schließe Menü bei Klick außerhalb
    const closeMenu = (e) => {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener("click", closeMenu);
      }
    };

    setTimeout(() => document.addEventListener("click", closeMenu), 10);
  }


  // ============================================================================
  // HAUPTFUNKTION: CHECKLIST-BLOCK VERARBEITEN
  // ============================================================================

  processChecklistBlock(source, el, ctx) {

    // -------------------------
    // Hilfsfunktion: Fortschrittsbalken aktualisieren
    // -------------------------

    const updateProgressBar = (tbody, progressFill, progressCounter) => {
      const totalTasks = tbody.querySelectorAll("tr:not(.checklist-separator-row)").length;
      const completedTasks = tbody.querySelectorAll('.checklist-checkbox[data-status="x"], .checklist-checkbox[data-status="X"]').length;
      const progress = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;

      progressFill.style.width = `${progress}%`;
      progressCounter.textContent = `${completedTasks}/${totalTasks}`;

      let hue = 0;
      if (progress <= 50) {
        hue = progress * 1.2;
      } else {
        hue = 60 + (progress - 50) * 1.2;
      }
      progressFill.style.backgroundColor = `hsl(${hue}, 85%, 50%)`;
    };

    // -------------------------
    // Hilfsfunktion: Status in Datei speichern
    // -------------------------

    const saveTaskStatus = async (originalLine, newStatus) => {
      const file = this.app.vault.getAbstractFileByPath(ctx.sourcePath);
      if (!file) return;

      const content = await this.app.vault.read(file);
      const contentLines = content.split("\n");

      let blockStart = -1;
      let blockEnd = -1;

      // Versuche, den Block über getSectionInfo zu finden
      const sectionInfo = ctx.getSectionInfo(el);

      if (sectionInfo) {
        // Suche den Block, der diese Zeile enthält
        for (let i = 0; i < contentLines.length; i++) {
          if (contentLines[i].trim().startsWith("```checklist")) {
            const potentialStart = i;
            for (let j = i + 1; j < contentLines.length; j++) {
              if (contentLines[j].trim() === "```") {
                // Prüfe, ob dieser Block die richtige Position hat
                if (i <= sectionInfo.lineStart && j >= sectionInfo.lineStart) {
                  blockStart = potentialStart;
                  blockEnd = j;
                  break;
                }
                break;
              }
            }
            if (blockStart !== -1) break;
          }
        }
      }

      // Fallback: Nimm den ersten Block
      if (blockStart === -1) {
        for (let i = 0; i < contentLines.length; i++) {
          if (contentLines[i].trim().startsWith("```checklist")) {
            blockStart = i;
            for (let j = i + 1; j < contentLines.length; j++) {
              if (contentLines[j].trim() === "```") {
                blockEnd = j;
                break;
              }
            }
            break;
          }
        }
      }

      if (blockStart !== -1 && blockEnd !== -1) {
        // Extrahiere den Inhalt ohne Status aus originalLine
        const contentWithoutStatus = originalLine.replace(/^\s*\[.\]\s*/, "").trim();

        // Suche nach der Zeile im Block basierend auf dem Inhalt
        for (let i = blockStart + 1; i < blockEnd; i++) {
          const currentLine = contentLines[i];
          const currentContentWithoutStatus = currentLine.replace(/^\s*\[.\]\s*/, "").trim();

          // Wenn der Inhalt übereinstimmt, aktualisiere diese Zeile
          if (currentContentWithoutStatus === contentWithoutStatus) {
            // Behalte das ursprüngliche Whitespace bei
            const leadingWhitespace = currentLine.match(/^\s*/)[0];
            const updatedLine = `${leadingWhitespace}[${newStatus}] ${contentWithoutStatus}`;
            contentLines[i] = updatedLine;

            await this.app.vault.modify(file, contentLines.join("\n"));
            break;
          }
        }
      }
    };

    // -------------------------
    // SCHRITT 1: Header-Zeile finden
    // -------------------------

    const lines = source.trim().split("\n");
    let headers = this.settings.defaultColumns;  // Standard-Spalten
    let headerLineIndex = -1;

    // Suche nach Custom-Header-Zeile (beginnt mit |)
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // Header-Zeile gefunden? (beginnt mit | aber nicht mit [.])
      if (line.startsWith("|") && !line.match(/^\[.\]/)) {
        headers = line.split("|").map((h) => h.trim()).filter((h) => h);
        headerLineIndex = i;
        break;
      }
    }


    // -------------------------
    // SCHRITT 2: Tabelle erstellen
    // -------------------------

    const containerClasses = ["checklist-table-container"];
    if (this.settings.alwaysShowControls) {
      containerClasses.push("checklist-always-show-controls");
    }
    const container = el.createDiv({ cls: containerClasses.join(" ") });
    const table = container.createEl("table", { cls: "checklist-table" });


    // -------------------------
    // Header-Zeile rendern
    // -------------------------

    const thead = table.createEl("thead");
    const headerRow = thead.createEl("tr");

    // Leere Checkbox-Spalte
    headerRow.createEl("th", { text: "", cls: "checklist-header-checkbox" });

    // Spalten-Header erstellen
    headers.forEach((header, index) => {
      const headerClasses = [];

      if (index === 0) headerClasses.push('checklist-header-thema');
      if (index === 1) headerClasses.push('checklist-header-aufgabe');

      headerRow.createEl('th', {
        text: header,
        cls: headerClasses.join(' ')
      });
    });


    // -------------------------
    // SCHRITT 3: Datenzeilen rendern
    // -------------------------

    const tbody = table.createEl("tbody");

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();

      // Überspringe leere Zeilen und Header-Zeile
      if (!line || i === headerLineIndex) continue;

      // --- Separator-Zeile erkennen (---) ---
      if (line.match(/^-{3,}$/)) {
        const separatorRow = tbody.createEl("tr", { cls: "checklist-separator-row" });
        const separatorCell = separatorRow.createEl("td", {
          cls: "checklist-separator-cell",
          attr: { colspan: (headers.length + 1).toString() }
        });
        separatorCell.createEl("hr", { cls: "checklist-separator-line" });
        continue;
      }

      // --- Neue Zeile erstellen ---
      const row = tbody.createEl("tr");
      row.setAttribute("data-original-line", line);


      // --- Checkbox-Zelle ---
      const checkboxCell = row.createEl("td", { cls: "checklist-checkbox-cell" });

      // Extrahiere Status aus [x] oder [ ] am Zeilenanfang
      let rowData = line;
      let taskStatus = " ";
      const statusMatch = line.match(/^\[(.)\]/);

      if (statusMatch) {
        taskStatus = statusMatch[1];
        rowData = line.replace(/^\[.\]\s*/, "");  // Entferne [x] vom Text
      }

      // Checkbox erstellen
      const checkboxDiv = checkboxCell.createDiv({ cls: "checklist-checkbox" });
      checkboxDiv.setAttribute("data-status", taskStatus);
      this.updateCheckboxAppearance(checkboxDiv, taskStatus, row);

      // Linksklick: Toggle zwischen " " und "x"
      checkboxDiv.addEventListener("click", async (e) => {
        e.preventDefault();
        const currentStatus = checkboxDiv.getAttribute("data-status") || " ";
        const newStatus = currentStatus === " " ? "x" : " ";
        checkboxDiv.setAttribute("data-status", newStatus);
        this.updateCheckboxAppearance(checkboxDiv, newStatus, row);

        // Speichere Status und aktualisiere Fortschrittsbalken
        const originalLine = row.getAttribute("data-original-line");
        await saveTaskStatus(originalLine, newStatus);

        const progressFill = container.querySelector(".checklist-progress-fill");
        const progressCounter = container.querySelector(".checklist-progress-counter");
        if (progressFill && progressCounter) {
          updateProgressBar(tbody, progressFill, progressCounter);
        }
      });

      // Rechtsklick: Zeige Status-Menü
      checkboxDiv.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        this.showTaskStatusMenu(e, checkboxDiv, row, tbody, container, saveTaskStatus, updateProgressBar);
      });


      // --- Daten-Zellen ---

      // Spalten-Daten extrahieren (durch | oder // getrennt)
      let cells;

      if (rowData.includes("|")) {
        cells = rowData.split("|").map((c) => c.trim()).filter((c) => c);
      }
      else if (rowData.includes("//")) {
        cells = rowData.split("//").map((c) => c.trim());
      }
      else {
        cells = [rowData];
      }

      // Zellen rendern
      cells.forEach(async (cellData, index) => {
        var _a2;
        const cell = row.createEl("td");

        // Wenn Zelle Links enthält: Markdown-Renderer nutzen
        if (cellData.includes("[[") || cellData.includes("](") || cellData.includes("http")) {
          const wrapper = cell.createDiv({ cls: "checklist-cell-content" });

          // Erste Spalte fett?
          if (index === 0 && ((_a2 = headers[0]) == null ? void 0 : _a2.toLowerCase().includes("thema"))) {
            wrapper.addClass("checklist-cell-bold");
          }

          // Rendere Markdown (für [[Links]], [Links](url), etc.)
          await import_obsidian.MarkdownRenderer.render(
            this.app,
            cellData,
            wrapper,
            ctx.sourcePath,
            this
          );
        }
        // Normaler Text
        else {
          if (index === 0 && ((_a2 = headers[0]) == null ? void 0 : _a2.toLowerCase().includes("thema"))) {
            cell.createEl("strong", { text: cellData });
          } else {
            cell.setText(cellData);
          }
        }
      });

      // Fülle fehlende Spalten mit leeren Zellen auf
      for (let j = cells.length; j < headers.length; j++) {
        row.createEl("td", { text: "" });
      }
    }


    // -------------------------
    // SCHRITT 4: Fortschrittsbalken
    // -------------------------

    // Zähle Tasks (nur normale Zeilen, keine Separator)
    const totalTasks = tbody.querySelectorAll("tr:not(.checklist-separator-row)").length;
    const completedTasks = tbody.querySelectorAll('.checklist-checkbox[data-status="x"], .checklist-checkbox[data-status="X"]').length;
    const progress = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;

    // Erstelle Fortschrittsbalken
    const progressContainer = container.createDiv({ cls: "checklist-progress-container" });
    const progressBar = progressContainer.createDiv({ cls: "checklist-progress-bar" });
    const progressFill = progressBar.createDiv({ cls: "checklist-progress-fill" });
    const progressCounter = progressContainer.createDiv({
      cls: "checklist-progress-counter",
      text: `${completedTasks}/${totalTasks}`
    });

    // Setze Fortschritt und Farbe
    progressFill.style.width = `${progress}%`;

    // Berechne Farbverlauf basierend auf Fortschritt (rot → orange → gelb → grün)
    let hue = 0;
    if (progress <= 50) {
      // 0-50%: Rot (0) → Gelb (60)
      hue = progress * 1.2;
    } else {
      // 50-100%: Gelb (60) → Grün (120)
      hue = 60 + (progress - 50) * 1.2;
    }
    progressFill.style.backgroundColor = `hsl(${hue}, 85%, 50%)`;

    // -------------------------
    // SCHRITT 5: "Neue Aufgabe" Button (in Progress Container)
    // -------------------------

    const addButton = progressContainer.createEl("button", {
      cls: "checklist-add-button",
      text: "+"
    });

    addButton.addEventListener("click", () => {

      // Erstelle neue editierbare Zeile
      const newRow = tbody.createEl("tr", { cls: "checklist-editing-row" });

      // Checkbox für neue Zeile
      const checkboxCell = newRow.createEl("td", { cls: "checklist-checkbox-cell" });
      const checkboxDiv = checkboxCell.createDiv({ cls: "checklist-checkbox" });
      checkboxDiv.setAttribute("data-status", " ");
      this.updateCheckboxAppearance(checkboxDiv, " ", newRow);

      // Input-Felder für jede Spalte erstellen
      const inputFields = [];

      headers.forEach((header, index) => {
        const cell = newRow.createEl("td");
        const input = cell.createEl("input", {
          cls: "checklist-input-field",
          attr: { placeholder: header, type: "text" }
        });
        inputFields.push(input);

        // Fokussiere erstes Feld
        if (index === 0) {
          setTimeout(() => input.focus(), 10);
        }

        // Enter = Speichern, Escape = Abbrechen
        input.addEventListener("keydown", async (e) => {
          if (e.key === "Enter") {
            await saveNewTask();
          }
          else if (e.key === "Escape") {
            newRow.remove();
          }
        });
      });


      // --- Speichern-Funktion ---
      const saveNewTask = async () => {
        // Sammle Werte aus Input-Feldern
        const values = inputFields.map(input => input.value.trim());

        // Baue neue Zeile: [ ] Wert1 | Wert2 | Wert3
        const newTaskLine = "[ ] " + values.join(" | ");

        // Finde Datei
        const file = this.app.vault.getAbstractFileByPath(ctx.sourcePath);
        if (!file) return;

        // Lese Datei-Inhalt
        const content = await this.app.vault.read(file);
        const contentLines = content.split("\n");
        const sourceNormalized = source.trim();

        let blockStart = -1;
        let blockEnd = -1;

        // Finde den richtigen ```checklist Block
        for (let i = 0; i < contentLines.length; i++) {
          if (contentLines[i].trim().startsWith("```checklist")) {
            blockStart = i;
            let blockContent = [];

            // Sammle Block-Inhalt
            for (let j = i + 1; j < contentLines.length; j++) {
              if (contentLines[j].trim() === "```") {
                blockEnd = j;
                break;
              }
              blockContent.push(contentLines[j]);
            }

            // Ist das der richtige Block? (Inhalts-Vergleich)
            if (blockContent.join("\n").trim() === sourceNormalized) {
              break;
            } else {
              blockStart = -1;
              blockEnd = -1;
            }
          }
        }

        // Füge neue Zeile vor ``` ein
        if (blockStart !== -1 && blockEnd !== -1) {
          contentLines.splice(blockEnd, 0, newTaskLine);
          await this.app.vault.modify(file, contentLines.join("\n"));
        }
      };


      // Speichern-Button (✓) zur letzten Zelle hinzufügen
      const lastInput = inputFields[inputFields.length - 1];
      const saveBtn = lastInput.parentElement.createEl("button", {
        cls: "checklist-save-button",
        text: "✓"
      });
      saveBtn.addEventListener("click", saveNewTask);
    });
  }


  // ============================================================================
  // SETTINGS VERWALTUNG
  // ============================================================================

  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    updateLocale(this.settings);
  }

  async saveSettings() {
    await this.saveData(this.settings);
    updateLocale(this.settings);
  }
};


// ============================================================================
// SETTINGS TAB
// ============================================================================

var ChecklistTableSettingTab = class extends import_obsidian.PluginSettingTab {

  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }

  display() {
    const { containerEl } = this;
    containerEl.empty();

    containerEl.createEl("h2", { text: t("settingsTitle") });

    // Setting: Sprache
    new import_obsidian.Setting(containerEl)
      .setName(t("settingsLanguage"))
      .setDesc(t("settingsLanguageDesc"))
      .addDropdown((dropdown) =>
        dropdown
          .addOption("auto", t("languageAuto"))
          .addOption("en", t("languageEnglish"))
          .addOption("de", t("languageGerman"))
          .setValue(this.plugin.settings.locale)
          .onChange(async (value) => {
            this.plugin.settings.locale = value;
            await this.plugin.saveSettings();
            // Refresh Settings-Tab nach Sprachwechsel
            this.display();
          })
      );

    // Setting: Standard-Spalten
    new import_obsidian.Setting(containerEl)
      .setName(t("settingsDefaultColumns"))
      .setDesc(t("settingsDefaultColumnsDesc"))
      .addText((text) =>
        text
          .setPlaceholder(t("settingsPlaceholder"))
          .setValue(this.plugin.settings.defaultColumns.join(", "))
          .onChange(async (value) => {
            this.plugin.settings.defaultColumns = value.split(",").map((s) => s.trim());
            await this.plugin.saveSettings();
          })
      );

    // Setting: Steuerelemente immer anzeigen
    new import_obsidian.Setting(containerEl)
      .setName(t("settingsAlwaysShowControls"))
      .setDesc(t("settingsAlwaysShowControlsDesc"))
      .addToggle((toggle) =>
        toggle
          .setValue(this.plugin.settings.alwaysShowControls)
          .onChange(async (value) => {
            this.plugin.settings.alwaysShowControls = value;
            await this.plugin.saveSettings();
          })
      );
  }
};
